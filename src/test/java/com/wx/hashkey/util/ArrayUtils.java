package com.wx.hashkey.util;


//为AES加密提供方法
public class ArrayUtils {
	/**
	 * 合并数组
	 * 
	 * @param firstArray  第一个数组
	 * @param secondArray 第二个数组
	 * @return 合并后的数组
	 */
	public static byte[] concat(byte[] firstArray, byte[] secondArray) {
		if (firstArray == null || secondArray == null) {
			return null;
		}
		byte[] bytes = new byte[firstArray.length + secondArray.length];
		System.arraycopy(firstArray, 0, bytes, 0, firstArray.length);
		System.arraycopy(secondArray, 0, bytes, firstArray.length, secondArray.length);
		return bytes;
	}

	/**
	 * 去除数组中的补齐
	 * 
	 * @param paddingBytes 源数组
	 * @param dataLength   去除补齐后的数据长度
	 * @return 去除补齐后的数组
	 */
	public static byte[] noPadding(byte[] paddingBytes, int dataLength) {
		if (paddingBytes == null) {
			return null;
		}

		byte[] noPaddingBytes = null;
		if (dataLength > 0) {
			if (paddingBytes.length > dataLength) {
				noPaddingBytes = new byte[dataLength];
				System.arraycopy(paddingBytes, 0, noPaddingBytes, 0, dataLength);
			} else {
				noPaddingBytes = paddingBytes;
			}
		} else {
			int index = paddingIndex(paddingBytes);
			if (index > 0) {
				noPaddingBytes = new byte[index];
				System.arraycopy(paddingBytes, 0, noPaddingBytes, 0, index);
			}
		}

		return noPaddingBytes;
	}

	/**
	 * 获取补齐的位置
	 * 
	 * @param paddingBytes 源数组
	 * @return 补齐的位置
	 */
	private static int paddingIndex(byte[] paddingBytes) {
		for (int i = paddingBytes.length - 1; i >= 0; i--) {
			if (paddingBytes[i] != 0) {
				return i + 1;
			}
		}
		return -1;
	}
}
